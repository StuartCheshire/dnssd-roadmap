<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<!--
Check output with <http://tools.ietf.org/tools/idnits/>
-->

<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.35) -->

<!-- give errors regarding ID-nits and DTD validation -->
<?rfc strict="yes" ?>

<!-- control the table of contents (ToC) -->
<!-- generate a ToC -->
<?rfc toc="no"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<?rfc tocdepth="3"?>

<!-- control references -->
<!-- use anchors instead of numbers for refs, i.e, [RFC2119] instead of [1] -->
<?rfc symrefs="yes"?>
<!-- sort the reference entries alphabetically -->
<?rfc sortrefs="no" ?>

<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<!-- do not start each main section on a new page -->
<?rfc compact="yes" ?>
<!-- keep one blank line between list items -->
<?rfc subcompact="no" ?>

<!-- encourage use of "xml2rfc" tool -->
<?rfc rfcprocack="yes" ?>
<!-- end of list of popular I-D processing instructions -->

<rfc category="info" docName="draft-cheshire-dnssd-roadmap-02" ipr="trust200902">

  <front>
    <title abbrev='Service Discovery Road Map'>Service Discovery Road Map</title>
    <author initials='S.' surname='Cheshire' fullname='Stuart Cheshire'>
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>1 Infinite Loop</street>
          <city>Cupertino</city>
          <region>California</region>
          <code>95014</code>
          <country>USA</country>
        </postal>
        <phone>+1 408 974 3207</phone>
        <email>cheshire@apple.com</email>
      </address>
    </author>
    <date year='2018' month='October' day='22'/>
    <area>Internet</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>DNS-Based Service Discovery</keyword>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>Over the course of several years, a rich collection of technologies
      has developed around DNS-Based Service Discovery, described across
      multiple documents. This “Road Map” document gives an overview of
      how these related but separate technologies (and their documents) fit
      together, to facilitate service discovery in various environments.</t>
    </abstract>
  </front>

  <middle>

    <section title="Road Map">
      <t><xref target="RFC6763">DNS-Based Service Discovery</xref>
      is a component of Zero Configuration Networking
      <xref target="RFC6760"/> <xref target="ZC"/>.</t>

      <t>Over the course of several years, a rich collection of technologies has
      developed around DNS-Based Service Discovery.
      These various related but separate technologies are described across multiple documents.
      This “Road Map” document gives an overview of how these technologies (and their documents)
      fit together to facilitate service discovery across a broad range of operating environments,
      from small scale zero-configuration networks to large scale administered networks,
      from local area to wide area,
      and from low-speed wireless links in the kb/s range to high-speed wired links
      operating at multiple Gb/s.</t>

      <t>Not all of the available components are necessary or appropriate in all scenarios.
      One goal of this “Road Map” document is to provide guidance about which components
      to use depending on the problem being solved.</t>

      <t>
      </t>

      <t>
      </t>

      <t>
      </t>

    </section>

    <section anchor="Types" title="Namespace of Service Types">

      <t>The single most important concept in service discovery is the
      namespace specifying how different service types are identified.
      This is how a client communicates what it needs, and how a server
      communicates what it offers.
      For a client to discover a server, the client and server need to
      have a common language to describe what they need and what they offer.
      They need to use the same namespace of service types,
      otherwise they may actually speak the same application protocol over the
      air or on the wire, and may in fact be completely compatible, and yet
      may be unable to detect this because they are using different names
      to refer to the same actual service.
      Hence, having a consistent namespace of service types
      is the essential prerequisite for any useful service discovery.</t>

      <t>IANA manages the registry of Service Types <xref target="RFC6335"/><xref target="STR"/>.
      This registry of Service Types can (and should) be used in any
      service discovery protocol as the vocabulary for describing *all*
      IP-based services, not only
      <xref target="RFC6763">DNS-Based Service Discovery</xref>.</t>

      <t>In this document we focus on the use of the
      <xref target="STR">IANA Service Type Registry</xref>
      in conjunction with DNS-Based Service Discovery, though
      that should not be taken in any way to imply any criticism of
      other service discovery protocols sharing the same namespace of
      service types. In different circumstances different Service
      Discovery protocols are appropriate.</t>

      <t>For example, for service discovery of services potentially
      available via a Wi-Fi access point, prior to association with that
      Wi-Fi access point, when no IP communication has yet been established, a
      service discovery protocol may use raw 802.11 frames, not
      necessarily IP, UDP, or DNS-formatted messages.
      For Service Discovery using peer-to-peer Wi-Fi technologies, without
      any Wi-Fi access point at all, it may also be preferable to use
      raw 802.11 frames instead of IP, UDP, or DNS-formatted messages.
      Service Discovery using IEEE 802.15.4 radios may use yet another
      over-the-air protocol.
      What is important is that they all share
      the same vocabulary to describe all IP-based services.
      Using the same service type vocabulary means that
      client and server software, using agnostic APIs to consume and
      offer services on the network, has a common language to identify
      those services, independent of the medium or the particular
      service discovery protocol in use on that medium. Just as TCP/IP
      runs on many different link layers, and the concept of using an IP
      address to identify a particular peer is consistent across many
      different link layers, the concept of using a name from the IANA
      Service Type Registry to identify a particular service type also
      needs to be consistent across all IP-supporting link layers.</t>

      <t>Originally, the IANA Service Type Registry
      <xref target="RFC6335"/><xref target="STR"/>
      used the term "Service Name" rather than "Service Type".
      Later it became clear that this term could be ambiguous.
      For a given service instance on the network,
      there is the machine-visible name of the type of service it provides,
      and the human-visible name of the particular instance of that type of service.
      For clarity, this document and related specifications use the term
      "Service Type" to denote the machine-visible name of the type of service,
      and the term "Instance Name" to denote the human-visible name of a particular instance.</t>

<?rfc needLines="30" ?>
    </section>

    <section title="Service Discovery Operational Model">

<?rfc subcompact="yes" ?>
      <t>The original
      <xref target="RFC6763">DNS-Based Service Discovery specification</xref>
      used the terms
      "register" (advertise a service),
      "browse" (discover service instances), and
      "resolve" (get IP address and port for a specific service instance).
      This terminology is reflective of the thinking at the time,
      which viewed service discovery as a new and separate step,
      added to existing networking code.
      For example, a server would first open a listening socket as it always had,
      and then "register" that listening socket with the service discovery engine.
      Similarly, a client would first "resolve" a service instance to an IP address
      and port, and then, having done that, "connect" to that IP address and port.</t>

      <t>More recent thinking in this area <xref target="RFC8305"/> has come to
      the conclusion that it is preferable wherever possible to insulate application
      software from networking details like having to decide between IPv4 and IPv6,
      having to decide among multiple IP addresses of either or both address
      families, and having to decide among multiple available network interfaces.
      Consequently this document and related specifications adopt newer terminology as follows:
        <list style='numbers'>
          <t>Offer</t>
          <t>Enumerate</t>
          <t>Use</t>
        </list>
      </t>
<?rfc subcompact="no" ?>

      <t>The first step, “Offer”, is when a server is offering a service using some
      application-layer protocol, on a listening TCP or UDP (or other transport protocol)
      port, and wishes to make that known to other devices.
      This encompasses both making a listening socket (or the equivalent concept
      in whatever underlying networking API is being used) and advertising the
      existence of that listening socket via a service discovery mechanism.</t>

      <t>The second step, “Enumerate”, is when a client
      device wishes to perform some action, but does not yet know which particular
      service instance will be used to perform that action.
      For example, when a user taps the “AirPrint” button on an iPhone or iPad, the
      iPhone or iPad knows that the user wishes to print, but not which particular printer to use.
      The desired *function* is known (IPP printing), but not the particular instance.
      In this case, the client device needs to enumerate the list of available
      service instances that are able to perform the desired task.
      In some cases this list of service instances is presented to a human user to choose from;
      in some cases it is software that examines the list of available service instances
      and determines the best one to use.
      This second step is the operation that was called "browsing"
      in the original specifications.</t>

      <t>The third step, “Use”, is when particular service instance has
      been selected, and the client wants to make use of that service instance.
      This encompasses both the "resolve" step
      (finding IP address(es) and port(s) for the service instance)
      and the subsequent steps to establish communication with it,
      which may include details like address family selection,
      interface selection, transport protocol selection, etc.
      Ideally, application-layer code should never be exposed to IP addresses at all,
      just as application-layer code today is generally not exposed to details like
      MAC addresses <xref target="RFC8305"/>.</t>

      <t>The second and third steps are intentionally separate.
      In the second step, a limited amount of information (typically just the name)
      is requested about a large number of service instances.
      In the third step more detailed information
      (e.g, target host IP address, port number, etc.)
      is requested about one specific service instance.
      Requesting all the detailed information about all available
      service instances would be inefficient and wasteful on the network.
      If the information about services on the network is imagined as a table,
      then the second step is requesting just one column from that table (the name column)
      and the third step is requesting just one row from that table
      (the information pertaining to just one named service instance).</t>

      <t>To give a concrete example, clicking the “+” button in the printer settings on macOS
      is an operation performing the second step.
      It is requesting the names of all available printers.
      Depending on the specific use case, this step may be performed only rarely.
      For example, a user may do this just one once, the first time they
      configure their computer to use their preferred printer, and never again.</t>

      <t>Once a desired printer has been chosen and configured,
      subsequent printing of documents is an operation performing the third step.
      This step may be done frequently, perhaps multiple times per day.
      This third step is important because, in a world of DHCP, IPv6 Stateless Autoconfiguration,
      and similar dynamic address allocation schemes, a printer's IP address could change from
      day to day, and to use the printer, its current address must be known.
      However, this third step need not be performed for every printer on the network,
      just the specific printer that is about to be used.
      Also, it is not necessary to repeat the second step again,
      learning the names of every printer on the network,
      if the client device already knows the name of the printer it intends to use.</t>

      <t><xref target="RFC6763">DNS-Based Service Discovery</xref>
      implements these three principal service discovery operations using
      DNS records and queries, either using
      <xref target="RFC6762">Multicast DNS</xref>
      (for queries limited to the local link)
      or conventional
      unicast DNS <xref target="RFC1034"/> <xref target="RFC1035"/>
      (for queries beyond the local link).</t>

      <t>Other service discovery protocol achieve the same semantics
      using different packet formats and mechanisms.</t>

      <t>One incidental benefit of using DNS as the foundation layer
      for service discovery, in cases where that makes sense, is
      that both Multicast DNS and conventional unicast DNS are also used provide
      name resolution (mapping host names to IP addresses).
      There is some efficiency and code reuse gained by using the same
      underlying protocol for both service discovery and naming.</t>

      <t>A final requirement is that the service discovery protocol should not only perform discovery
      at a single moment in time, but should also provide ongoing change notification
      (sometimes called “Publish &amp; Subscribe”).
      Clients need to be notified in a timely fashion when new data of interest appears,
      when data of interest changes, and, equally importantly, when data of interest goes away ("goodbye packets").
      Without support for ongoing change notification, clients would be
      forced to resort to polling to keep data up to date, which is
      inefficient and wasteful on the network.</t>

      <t><xref target="RFC6762">Multicast DNS</xref> implicitly includes
      change notification by virtue of announcing record creation, update, and deletion, via IP Multicast,
      which allows these changes to be seen by all peers on the same link
      (i.e., same broadcast domain).</t>

      <t>Conventional unicast DNS <xref target="RFC1034"/> <xref target="RFC1035"/>
      has historically not had broad support for change notification.
      This capability is added via the new mechanism for
      <xref target="Push">DNS Push Notifications</xref>.</t>

      <t>When using <xref target="RFC6763">DNS-Based Service Discovery</xref>
      there are two aspects to consider:
      firstly how the clients determine the appropriate DNS names to query (and what query mechanisms to use)
      and secondly how the relevant information got into the DNS namespace in
      the first place, so as to be available when clients query for it.</t>

      <t>The available namespaces are discussed broadly in <xref target="Namespace"/> below.
      Client operation is then discussed in detail in <xref target="Client"/>, and
      server operation is discussed in detail in <xref target="Server"/>.</t>

      <t>
      </t>

<?rfc needLines="30" ?>
    </section>

    <section anchor="Namespace" title="Service Discovery Namespace">
      <t>When used with <xref target="RFC6762">Multicast DNS</xref>
      Service Discovery queries necessarily use the “.local” parent domain
      reserved for this purpose <xref target="SUDN"/>.</t>

      <t>When used with conventional
      unicast DNS <xref target="RFC1034"/> <xref target="RFC1035"/>
      some other domain must be used.</t>

      <t>For individuals and organizations with
      a globally-unique domain name registered to them,
      their globally-unique domain name,
      or a subdomain of it, can be used for service discovery.</t>

      <t>However, it would be convenient for advanced service discovery to be
      available even to people who haven’t taken the step of registering and
      paying annually for a globally-unique domain name.
      For these people it would be useful if devices arrived preconfigured with
      some suitable factory-default service discovery domain, such as
      “services.home.arpa” <xref target="RFC8375"/>.
      Services published in this factory-default service discovery domain
      are not globally unique or globally resolvable, but they can
      have scope larger than the single link provided by Multicast DNS.</t>

      <t>
      </t>

<?rfc needLines="30" ?>
    </section>

    <section anchor="Client" title="Client Configuration and Operation">

      <t>When using <xref target="RFC6763">DNS-Based Service Discovery</xref>,
      clients have to choose what DNS names to query.</t>

      <t>When used with <xref target="RFC6762">Multicast DNS</xref>
      on the local link,
      queries are necessarily performed in the “.local” parent domain
      reserved for this purpose <xref target="SUDN"/>.</t>

      <t>For discovery beyond the local link, a unicast DNS domain must be used.
      This unicast DNS domain can be configured manually by the user,
      or it can be learned dynamically from the network
      (as has been done for many years at IETF meetings to facilitate discovery
      of the IETF Terminal Room printer, from outside the IETF Terminal Room).
      In the <xref target="RFC6763">DNS-SD specification</xref> section 11,
      “Discovery of Browsing and Registration Domains (Domain Enumeration)”,
      describes how a client device learns one or more recommended service
      discovery domains from the network, using the special “lb._dns-sd._udp” query.
      All of the details from that specification are not repeated here.
      <vspace />
      A walk-through describing one real-world example of how this works, using
      discovery of the IETF Terminal Room printer as a specific concrete case
      study, is given in <xref target="app-a" format="none">Appendix A</xref>.
      </t>

      <t>Given the service type that the user or client device is seeking
      (see <xref target="Types"/>)
      and one or more service discovery domains to look in, the client then
      sends its DNS queries, and processes the responses.</t>

      <t>For some uses, one-shot conventional DNS queries and responses
      are perfectly adequate, but for service discovery,
      where a list may be displayed on a screen for a user to see,
      it is desirable to keep that list up to date without the user
      having to repeatedly tap a “refresh” button, and without the
      software repeatedly polling the network on the user’s behalf.</t>

      <t>And early solution to provide asynchronous change notifications
      for unicast DNS was the UDP-based protocol
      <xref target="DNS-LLQ">DNS Long-Lived Queries</xref>.
      This was used, among other things, by 
      Apple’s <xref target="RFC6281">Back to My Mac Service</xref>
      introduced in Mac OS X 10.5 Leopard in 2007.</t>

      <t>A decade of operational experience has shown that an
      asynchronous change notification protocol built on TCP is preferable
      for a variety of reasons,
      so the IETF is has developed
      <xref target="Push">DNS Push Notifications</xref>.</t>

      <t>Because DNS Push Notifications is built on top of a DNS TCP connection,
      DNS Push Notifications adopts the conventions specified by
      <xref target="DSO">DNS Stateful Operations</xref>
      rather than inventing its own session management mechanisms.</t>

      <t>
      </t>

<?rfc needLines="30" ?>
    </section>

    <section anchor="Server" title="Server Configuration and Operation">
      <t><xref target="Client"/> above describes how clients perform their queries.
      The related question is
      how the relevant information got into the DNS namespace in
      the first place, so as to be available when clients query for it.</t>

      <t>One trivial way that relevant service discovery information can get into
      the DNS namespace is simply via manual configuration, creating
      the necessary PTR, SRV and TXT records <xref target="RFC6763"/> by hand,
      and indeed this is how the IETF Terminal Room printer has been advertised
      to IETF meeting attendees for many years.
      While this is easy for the experienced network operators at the IETF, it
      can be onerous to others less familiar with how to set up DNS-SD records.</t>

      <t>Hence it would be convenient to automate this process of populating
      the DNS namespace with relevant service discovery information.
      Two efforts are underway to address this need,
      the <xref target="DisProx">Service Discovery Proxy</xref>
      (see <xref target="dp"/>)
      and
      the <xref target="RegProt">Service Registration Protocol</xref>
      (see <xref target="srp"/>).</t>

      <section anchor="dp" title="Service Discovery Proxy">

      <t>The first technique in the direction of automatically populating the DNS namespace is the
      <xref target="DisProx">Service Discovery Proxy</xref>.
      This technology works with today’s existing devices that advertise
      services using Multicast DNS only
      (such as almost all network printers sold in the last decade).
      A Service Discovery Proxy is a device with a presence on the same link
      as the devices we wish to be able to discover from afar.
      A remote client sends unicast queries to the Discovery Proxy,
      which performs local Multicast DNS queries on behalf of the remote client,
      and then sends back the answers it discovers.</t>

      <t>Because the time it takes to receive Multicast DNS responses is uncertain,
      this mechanism benefits from being able to deliver asynchronous change
      notifications as new answers come in, using
      <xref target="DNS-LLQ">DNS Long-Lived Queries</xref> or the newer
      <xref target="Push">DNS Push Notifications</xref> on top of
      <xref target="DSO">DNS Stateful Operations</xref>.</t>

<?rfc needLines="30" ?>
      </section>

      <section title="Multicast DNS Discovery Relay">

      <t>As an alternative to having to be physically connected to the
      desired network link, a <xref target="DisProx">Service Discovery Proxy</xref>
      can use a <xref target="Relay">Multicast DNS Discovery Relay</xref>
      to give it a ‘virtual’ presence on a remote link.
      Indeed, when using Discovery Relays, a single Discovery Proxy
      can have a ‘virtual’ presence on hundreds of remote links.
      A single Discovery Proxy in the data center can serve the needs of an
      entire enterprise.
      This is modeled after the DHCP protocol.
      In simple residential scenarios the DHCP server resides in the
      home gateway, which is physically attached to the (single) local link.
      In complex enterprise networks, it is common to have a single centralized
      DHCP server, which resides in the data center and communicates
      with a multitude of simple lightweight BOOTP relay agents,
      implemented in the routers on each physical link.</t>

      </section>

      <section title="Service Discovery Broker">

      <t>Finally, when clients are communicating with multiple
      Service Discovery Proxies at the same time, this can be burdensome for
      the clients (which may be mobile and battery powered)
      and for the Service Discovery Proxies
      (which may have to serve hundreds of clients).
      This situation is remedied by use of a
      <xref target="Broker">Service Discovery Broker</xref>.
      A Service Discovery Broker is an intermediary between client and server.
      A client can issue a single query to the Service Discovery
      Broker and have the Service Discovery Broker do the hard work
      of issuing multiple queries on behalf of the client.
      And a Service Discovery Broker can shield a Service Discovery Proxy
      from excessive load by collapsing multiple duplicate queries from
      different client down to a single query to the Service Discovery Proxy.</t>

<?rfc needLines="40" ?>
      </section>

      <section anchor="srp" title="Service Registration Protocol">

      <t>The second technique in the direction of automatically populating the DNS namespace is the
      <xref target="RegProt">Service Registration Protocol</xref>.
      This technology is designed to enable future devices that will explicitly
      cooperate with the network infrastructure to advertise their services.</t>

      <t>The Service Registration Protocol is effectively DNS Update,
      with some minor additions.</t>

      <t>One addition to the basic DNS Update protocol is the introduction of a lifetime on DNS Updates,
      using the
      <xref target="DNS-UL">Dynamic DNS Update Lease EDNS(0) option</xref>.
      This option has similar semantics to a DHCP address lease,
      where a device is granted an address with with a certain DHCP lease lifetime,
      and if the device fails to renew the DHCP lease before it expires then the address
      will be reclaimed and become available to be allocated to a different device.
      In cases where DHCP is being used for address assignment, a device will generally request a
      DNS Update Lease with the same expiration time as its DHCP address lease.
      This way, if the device is abruptly disconnected from the network,
      around the same time as its address gets reclaimed
      its DNS records will also be garbage collected.</t>

      <t>The second addition to the basic DNS Update protocol is the introduction of information,
      carried using the <xref target="Owner">EDNS(0) OWNER Option</xref>,
      that tells the Service Registration server that the device
      will be going to sleep to save power,
      and how the Service Registration server can wake it up again on demand when needed.
      The use of power management information in the Service Registration
      messages allows devices to sleep to save power, which is especially
      beneficial for battery-powered devices in the home.</t>

      <t>The use of an explicit Service Registration Protocol is beneficial
      in networks where multicast is expensive, inefficient, or outright
      blocked, such as many Wi-Fi networks.
      An explicit Service Registration Protocol is also beneficial
      in networks where multicast and broadcast are supported poorly,
      if at all, such as some mesh networks.</t>

      </section>
    </section>

    <section anchor="security" title="Security Considerations">
      <t> As an informational document, this document
      introduces no new Security Considerations of its own.
      The various referenced documents each describe their
      own relevant Security Considerations as appropriate.</t>
<?rfc needLines="25" ?>
    </section>

  </middle>

  <back>
    <references title="Informative References">
      <?rfc include="reference.RFC.1034" ?>
      <?rfc include="reference.RFC.1035" ?>
      <?rfc include="reference.RFC.6281" ?>
      <?rfc include="reference.RFC.6335" ?>
      <?rfc include="reference.RFC.6760" ?>
      <?rfc include="reference.RFC.6762" ?>
      <?rfc include="reference.RFC.6763" ?>
      <?rfc include="reference.RFC.8305" ?>
      <?rfc include="reference.RFC.8375" ?>

      <?rfc include="reference.I-D.sctl-discovery-broker"       anchor='Broker' ?>
      <?rfc include="reference.I-D.ietf-dnssd-hybrid"           anchor='DisProx' ?>
      <?rfc include="reference.I-D.sekar-dns-llq"               anchor='DNS-LLQ' ?>
      <?rfc include="reference.I-D.sekar-dns-ul"                anchor='DNS-UL' ?>
      <?rfc include="reference.I-D.ietf-dnsop-session-signal"   anchor='DSO' ?>
      <?rfc include="reference.I-D.cheshire-edns0-owner-option" anchor='Owner' ?>
      <?rfc include="reference.I-D.ietf-dnssd-push"             anchor='Push' ?>
      <?rfc include="reference.I-D.sctl-service-registration"   anchor='RegProt' ?>
      <?rfc include="reference.I-D.sctl-dnssd-mdns-relay"       anchor='Relay' ?>

      <reference anchor="STR"
      target="http://www.iana.org/assignments/service-names-port-numbers/">
        <front>
          <title>Service Name and Transport Protocol Port Number Registry</title>
          <author/>
          <date/>
        </front>
      </reference>

      <reference anchor="SUDN"
      target="https://www.iana.org/assignments/special-use-domain-names/">
        <front>
          <title>Special-Use Domain Names Registry</title>
          <author/>
          <date/>
        </front>
      </reference>

      <reference anchor="ZC">
        <front>
          <title>Zero Configuration Networking: The Definitive Guide</title>
          <author initials="S." surname="Cheshire" fullname="Stuart Cheshire"/>
          <author initials="D.H." surname="Steinberg" fullname="Daniel H. Steinberg"/>
          <date year="2005" month="December"/>
        </front>
        <seriesInfo name="O'Reilly Media, Inc." value=""/>
        <seriesInfo name="ISBN" value="0-596-10100-7"/>
      </reference>

    </references>

<?rfc needLines="40" ?>
    <section anchor="app-a" title="IETF Terminal Room Printer Discovery Walk-Through">
        <t>For about a decade now, the talented IETF network staff have provided
        off-link DNS Service Discovery for the Terminal Room printer at IETF
        meetings three times a year.
        In the case of the IETF meetings the necessary DNS records are entered manually,
        whereas this document advocates for increased automation of that task,
        but either way the process by which clients query to discover services is the same.
        </t>

        <t>This appendix gives a detailed step-by step account of how this client query process works.
        It starts with a client joining the Wi-Fi network and doing a DHCP request,
        and ends with paper coming out of the printer.
        The reason the explanation is gives the specific details of every step is to avoid inadvertently having
        a hand-waving “and then a miracle occurs” part, which misses out some important detail.
        And one of the reasons for asking the IETF network team to set this up
        for IETF meetings is that operational use is an important reality check.
        When standing in front of a room, giving a presentation,
        if you miss out some vital step, people may not notice.
        When running an actual service used by actual people,
        if you miss out some vital step, no paper comes out of the printer,
        and everyone notices.
        </t>

        <t>Using a macOS computer, at an IETF meeting, you can repeat the steps
        illustrated here to see exactly how it works.
        Or you can simply press Cmd-P in any application and see that
        "term-printer" appears as an available printer, to confirm that it
        does in fact work.
        </t>

        <t>First, let’s see what the macOS computer learned from the local DHCP server:
        </t>

<figure><artwork align="left"><![CDATA[
  % scutil
  > list
   ...
   subKey [74] = State:/Network/Service/21B5304C...54B28F4CA1D2/DHCP
   ...
  
  > show State:/Network/Service/21B5304C...54B28F4CA1D2/DHCP
  <dictionary> {
   Option_15 : <data> 0x6d656574696e672e696574662e6f7267
   ...
  }
]]></artwork></figure>

        <t>Option_15 is Domain Name. To see what domain name,
        we need to decode the hexadecimal data to ASCII.</t>

<figure><artwork align="left"><![CDATA[
  % echo 6d656574696e672e696574662e6f7267 0A | xxd -r -p
  meeting.ietf.org
]]></artwork></figure>

      <section title="Domain Enumeration using PTR queries">

        <t>Our DHCP domain name is meeting.ietf.org.
        Does meeting.ietf.org recommend that we look
        in any Wide Area Service Discovery domains?
        This step is called Domain Enumeration <xref target="RFC6763"/>,
        and is performed using a DNS PTR query for a name with the special prefix "lb._dns-sd._udp":</t>

<figure><artwork align="left"><![CDATA[
  % dig lb._dns-sd._udp.meeting.ietf.org. ptr
  
  ; <<>> DiG 9.6-ESV-R4-P3 <<>> lb._dns-sd._udp.meeting.ietf.org. ptr
  ;; global options: +cmd
  ;; Got answer:
  ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 35624
  ;; flags: qr aa rd ra; 
                     QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 4
  
  ;; QUESTION SECTION:
  ;lb._dns-sd._udp.meeting.ietf.org. IN PTR
  
  ;; ANSWER SECTION:
  lb._dns-sd._udp.meeting.ietf.org. 3600 IN PTR meeting.ietf.org.
  
  ...
  
  ;; Query time: 8 msec
  ;; SERVER: 130.129.5.6#53(130.129.5.6)
  ;; WHEN: Wed Mar 13 10:16:40 2013
  ;; MSG SIZE  rcvd: 188
]]></artwork></figure>

        <t>In the middle there in the Answer Section you'll see that the answer to the PTR query is "meeting.ietf.org".
        In this case the answer is self-referential -- "meeting.ietf.org" is
        inviting us to look for services in "meeting.ietf.org",
        but the PTR record(s) could equally well point at any other domain,
        such as "services.ietf.org", or anything else.</t>

<?rfc needLines="28" ?>
        <t>Note that this answer does not depend on the client device being "on" the
        IETF meeting network, which is in any case a loosely defined concept at best.
        Nor does it depend on sending the DNS query to a DNS server that is "on"
        the IETF meeting network. Any capable DNS recursive resolver anywhere on
        the planet will give the same answer. We can test this by sending the
        same DNS PTR query to Google's 8.8.8.8 public resolver:</t>

<figure><artwork align="left"><![CDATA[
  % dig @8.8.8.8 lb._dns-sd._udp.meeting.ietf.org. ptr
  
  ; <<>> DiG 9.6-ESV-R4-P3 <<>>
                       @8.8.8.8 lb._dns-sd._udp.meeting.ietf.org. ptr
  ; (1 server found)
  ;; global options: +cmd
  ;; Got answer:
  ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 24571
  ;; flags: qr rd ra; QUERY:1, ANSWER:1, AUTHORITY:0, ADDITIONAL:0
  
  ;; QUESTION SECTION:
  ;lb._dns-sd._udp.meeting.ietf.org. IN PTR
  
  ;; ANSWER SECTION:
  lb._dns-sd._udp.meeting.ietf.org. 1532 IN PTR meeting.ietf.org.
  
  ;; Query time: 21 msec
  ;; SERVER: 8.8.8.8#53(8.8.8.8)
  ;; WHEN: Wed Mar 13 10:18:27 2013
  ;; MSG SIZE  rcvd: 64
]]></artwork></figure>

        <t>In the Answer Section you'll see that the answer is still "meeting.ietf.org".</t>

<?rfc needLines="28" ?>
        <t>In this example, this particular test was done at the 86th IETF in Orlando, Florida, in March 2013.
        The Google 8.8.8.8 public resolver still gave the correct answer, even though it was 13 hops away:</t>

<figure><artwork align="left"><![CDATA[
  % traceroute -q 1 8.8.8.8
  traceroute to 8.8.8.8 (8.8.8.8), 64 hops max, 52 byte packets
  1  rtra (130.129.80.2)  1.369 ms
  2  75-112-170-148.net.bhntampa.com (75.112.170.148)  14.494 ms
  3  bun2.tamp20-car1.bhn.net (71.44.3.73)  19.558 ms
  4  hun0-0-0-0-tamp20-cbr1.bhn.net (72.31.117.156)  20.730 ms
  5  xe-8-2-0.bar1.tampa1.level3.net (4.53.172.9)  13.052 ms
  6  ae-5-5.ebr1.miami1.level3.net (4.69.148.213)  27.413 ms
  7  ae-1-51.edge1.miami2.level3.net (4.69.138.75)  15.552 ms
  8  google-inc.edge1.miami2.level3.net (4.59.240.26)  48.852 ms
  9  209.85.253.118 (209.85.253.118)  21.118 ms
  10  216.239.48.192 (216.239.48.192)  21.890 ms
  11  216.239.48.192 (216.239.48.192)  23.221 ms
  12  *
  13  google-public-dns-a.google.com (8.8.8.8)  32.961 ms
]]></artwork></figure>

        <t>For the rest of this example we use the Google 8.8.8.8 public
        resolver for all the queries.</t>

        <t>In the case of IETF meetings the PTR is self-referential —
        meeting.ietf.org is advising us to look in meeting.ietf.org, but it
        could easily be set up to direct us elsewhere.
        However, since it’s suggesting we look for services in
        meeting.ietf.org, we'll do that.</t>

      </section>

<?rfc needLines="30" ?>
      <section title="Instance Enumeration using PTR queries on a macOS computer">

        <t>Once one or more service discovery domains have been determined,
        the client then looks for instances of the desired service type.
        This step is called Instance Enumeration
        and is also performed using a DNS PTR queries,
        using a name with a prefix indicating the type of service that is being sought.</t>

        <t>A macOS computer with appropriate
        printer drivers installed will look for instances
        of the service type "_pdl-datastream._tcp" in the domain "meeting.ietf.org", as shown below.
        This is typically performed just once, the first time the macOS computer is set up to use that printer.</t>

<figure><artwork align="left"><![CDATA[
  % dig +short @8.8.8.8 _pdl-datastream._tcp.meeting.ietf.org. ptr
  term-printer._pdl-datastream._tcp.meeting.ietf.org.
]]></artwork></figure>

        <t>There’s one printing service available here, called “term-printer”.
        That’s what you see when you press the “+” button in the Print &amp; Fax
        Preference Pane on macOS.</t>

      </section>

<?rfc needLines="30" ?>
      <section title="Printing from a macOS computer">

        <t>When the user actually prints something, macOS sends a DNS SRV query
        for the printer name learned in the previous Instance Enumeration step,
        to learn the target host and port for the service.
        This DNS SRV query is then followed by address queries for the target host's
        IPv4 and/or IPv6 addresses. The necessary address records are usually included in the
        Additional Section of the reply to the SRV query, so that these address queries
        can be answered from the local cache, without resulting in additional packets over the air.</t>

<figure><artwork align="left"><![CDATA[
  % dig +short @8.8.8.8 \
              term-printer._pdl-datastream._tcp.meeting.ietf.org. srv
  0 0 9100 term-printer.meeting.ietf.org.
  
  % dig +short @8.8.8.8 term-printer.meeting.ietf.org. AAAA
  2001:df8::48:200:74ff:fee0:6cf8
]]></artwork></figure>

        <t>This tells the computer that to use this printer,
        it must connect to [2001:df8::48:200:74ff:fee0:6cf8]:9100,
        using the installed printer driver, which speaks the appropriate
        vendor-specific printing protocol for that printer.</t>

      </section>

<?rfc needLines="30" ?>
      <section title="Instance Enumeration using PTR queries on an iOS device">

        <t>Printing from an iPhone or iPad is similar, except there are no
        vendor-specific printer drivers installed. Instead, printing from an
        iPhone or iPad uses the IETF Standard IPP printing protocol, using an
        IPP printer that supports at least URF (Universal Raster Format).
        Consequently, the iOS device sends its Instance Enumeration DNS PTR queries
        using the prefix "_universal._sub._ipp._tcp" to indicate that it is
        looking for the subset of IPP printers that support Universal Raster Format.
        </t>

<figure><artwork align="left"><![CDATA[
  % dig +short @8.8.8.8 \
                      _universal._sub._ipp._tcp.meeting.ietf.org. ptr
  term-printer._ipp._tcp.meeting.ietf.org.
]]></artwork></figure>

        <t>An iPhone or iPad will discover that there’s one URF-capable IPP-based printing
        service available here, called “term-printer”.
        It has the same name as the pdl-datastream printing service, and exists
        on the same physical hardware, but uses a different printing protocol.</t>

      </section>

      <section title="Printing from an iOS device">

        <t>When the user prints from their iPhone or iPad using AirPrint, iOS does these
        DNS SRV and address queries:</t>

<figure><artwork align="left"><![CDATA[
  % dig +short @8.8.8.8 term-printer._ipp._tcp.meeting.ietf.org. srv
  0 0 631 term-printer.meeting.ietf.org.
  
  % dig +short @8.8.8.8 term-printer.meeting.ietf.org. aaaa
  2001:df8::48:200:74ff:fee0:6cf8
]]></artwork></figure>

        <t>Note that the "_ipp._tcp" service has the same target hostname
        and IPv6 address as the "_pdl-datastream" service from the macOS example,
        but is accessed at a different TCP port on that hardware device.</t>

        <t>To use this printer, the iPhone or iPad connects to
        [2001:df8::48:200:74ff:fee0:6cf8]:631, and uses IPP to print.</t>

      </section>
    </section>
  </back>
</rfc>
