<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<!--
Check output with <http://tools.ietf.org/tools/idnits/>
-->

<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.35) -->

<!-- give errors regarding ID-nits and DTD validation -->
<?rfc strict="yes" ?>

<!-- control the table of contents (ToC) -->
<!-- generate a ToC -->
<?rfc toc="no"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<?rfc tocdepth="3"?>

<!-- control references -->
<!-- use anchors instead of numbers for refs, i.e, [RFC2119] instead of [1] -->
<?rfc symrefs="yes"?>
<!-- sort the reference entries alphabetically -->
<?rfc sortrefs="no" ?>

<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<!-- do not start each main section on a new page -->
<?rfc compact="yes" ?>
<!-- keep one blank line between list items -->
<?rfc subcompact="no" ?>

<!-- encourage use of "xml2rfc" tool -->
<?rfc rfcprocack="yes" ?>
<!-- end of list of popular I-D processing instructions -->

<rfc category="info" docName="draft-cheshire-dnssd-roadmap-01" ipr="trust200902">

  <front>
    <title abbrev='Service Discovery Road Map'>Service Discovery Road Map</title>
    <author initials='S.' surname='Cheshire' fullname='Stuart Cheshire'>
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>1 Infinite Loop</street>
          <city>Cupertino</city>
          <region>California</region>
          <code>95014</code>
          <country>USA</country>
        </postal>
        <phone>+1 408 974 3207</phone>
        <email>cheshire@apple.com</email>
      </address>
    </author>
    <date year='2018' month='March' day='18'/>
    <area>Internet</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>DNS-Based Service Discovery</keyword>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>Over the course of several years, a rich collection of technologies
      has developed around DNS-Based Service Discovery, described across
      multiple documents. This “Road Map” document gives an overview of
      how these related but separate technologies (and their documents) fit
      together, to facilitate service discovery in various environments.</t>
    </abstract>
  </front>

  <middle>

    <section title="Road Map">
      <t><xref target="RFC6763">DNS-Based Service Discovery</xref>
      is a component of Zero Configuration Networking
      <xref target="RFC6760"/> <xref target="ZC"/>.</t>

      <t>Over the course of several years, a rich collection of technologies has
      developed around DNS-Based Service Discovery.
      These various related but separate technologies are described across multiple documents.
      This “Road Map” document gives an overview of how these technologies (and their documents)
      fit together to facilitate service discovery across a broad range of operating environments,
      from small scale zero-configuration networks to large scale administered networks,
      from local area to wide area,
      and from low-speed wireless links in the kb/s range to high-speed wired links
      operating at multiple Gb/s.</t>

      <t>Not all of the available components are necessary or appropriate in all scenarios.
      One goal of this “Road Map” document is to provide guidance about which components
      to use depending on the problem being solved.</t>

      <t>
      </t>

      <t>
      </t>

      <t>
      </t>

    </section>

    <section anchor="Types" title="Namespace of Service Types">

      <t>The single most important concept in service discovery is the
      namespace specifying how different service types are identified.
      This is how a client communicates what it needs, and how a server
      communicates what it offers.
      For a client to discover a server, the client and server need to
      have a common language to describe what they need and what they offer.
      The need to use the same namespace of service types,
      otherwise they may actually speak the same application protocol over the
      air or on the wire, and may in fact be completely compatible, and yet
      may be unable to detect this because they are using different names
      to refer to the same actual service.
      Hence, having a consistent namespace of service types
      is the essential prerequisite for any useful service discovery.</t>

      <t>IANA manages the registry of Service Types <xref target="RFC6335"/><xref target="STR"/>.
      This registry of Service Types can (and should) be used in any
      service discovery protocol as the vocabulary for describing *all*
      IP-based services, not only
      <xref target="RFC6763">DNS-Based Service Discovery</xref>.</t>

      <t>In this document we focus on the use of the
      <xref target="STR">IANA Service Type Registry</xref>
      in conjunction with DNS-Based Service Discovery, though
      that should not be taken in any way to imply any criticism of
      other service discovery protocols sharing the same namespace of
      service types. In different circumstances different Service
      Discovery protocols are appropriate.</t>

      <t>For example, for service discovery of services potentially
      available via a Wi-Fi access point, prior to association with that
      Wi-Fi access point, when no IP link has yet been established, a
      service discovery protocol may use raw 802.11 frames, not
      necessarily IP, UDP, or DNS-formatted messages.
      For Service Discovery using peer-to-peer Wi-Fi technologies, without
      any Wi-Fi access point at all, it may also be preferable to use
      raw 802.11 frames instead of IP, UDP, or DNS-formatted messages.
      Service Discovery using IEEE 802.15.4 radios may use yet another
      over-the-air protocol.
      What is important is that they all share
      the same vocabulary to describe all IP-based services.
      Using the same service type vocabulary means that
      client and server software, using agnostic APIs to consume and
      offer services on the network, has a common language to identify
      those services, independent of the medium or the particular
      service discovery protocol in use on that medium. Just as TCP/IP
      runs on many different link layers, and the concept of using an IP
      address to identify a particular peer is consistent across many
      different link layers, the concept of using a name from the IANA
      Service Type Registry to identify a particular service type also
      needs to be consistent across all IP-supporting link layers.</t>

      <t>Originally, the IANA Service Type Registry
      <xref target="RFC6335"/><xref target="STR"/>
      used the term "Service Name" rather than "Service Type".
      Later it became clear that this term could be ambiguous.
      For a given service instance on the network,
      there is the machine-visible name of the type of service it provides,
      and the human-visible name of the particular instance of that type of service.
      For clarity, this document and related specifications use the term
      "Service Type" to denote the machine-visible name of the type of service,
      and the term "Instance Name" to denote the human-visible name of a particular instance.</t>

<?rfc needLines="30" ?>
    </section>

    <section title="Service Discovery Operational Model">

<?rfc subcompact="yes" ?>
      <t>The original
      <xref target="RFC6763">DNS-Based Service Discovery specifications</xref>
      used the terms
      "register" (advertise a service),
      "browse" (discover service instances), and
      "resolve" (get IP address and port for a specific service instance).
      This terminology is reflective of the thinking at the time,
      which viewed service discovery as a new and separate step,
      added to existing networking code.
      For example, a server would first open a listening socket as it always had,
      and then "register" that listening socket with the service discovery engine.
      Similarly, a client would first "resolve" a service instance to an IP address
      and port, and then, having done that, "connect" to that IP address and port.</t>

      <t>More recent thinking in this area has come to the conclusion that it is
      preferable wherever possible to insulate application software from networking
      details like having to decide between IPv4 and IPv6, having to decide among
      multiple IP addresses of either or both address families, and having to
      decide among multiple available network interfaces <xref target="RFC8305"/>.
      Consequently this document and related specifications adopt newer terminology as follows:
        <list style='numbers'>
          <t>Offer</t>
          <t>Enumerate</t>
          <t>Use</t>
        </list>
      </t>
<?rfc subcompact="no" ?>

      <t>The first step, “Offer”, is when a server is offering a service using some
      application-layer protocol, on a listening TCP or UDP (or other transport protocol)
      port, and wishes to make that known to other devices.
      This encompasses both making a listening socket (or the equivalent concept
      in whatever underlying networking API is being used) and advertising the
      existence of that listening socket via a service discovery mechanism.</t>

      <t>The second step, “Enumerate”, is when a client
      device wishes to perform some action, but does not yet know which particular
      service instance will be used to perform that action.
      For example, when a user taps the “AirPrint” button on an iPhone, the
      iPhone knows that the user wishes to print, but not which particular printer to use.
      The desired *function* is known (IPP printing), but not the particular instance.
      In this case, the client device needs to enumerate the list of available
      service instances that are able to perform the desired task.
      In most cases this list of service instances is presented to a human user to choose from;
      in some cases it is software that examines the list of available service instances
      and determines the best one to use.
      This second step is the operation that was called "browsing"
      in the original specifications.</t>

      <t>The third step, “Use”, is when particular service instance has
      been selected, and the client wants to make use of that service instance.
      This encompasses both the "resolve" step
      (finding IP address(es) and port(s) for the service instance)
      and the subsequent steps to establish communication with it,
      which may include details like address family selection,
      interface selection, transport protocol selection, etc.
      Ideally, application-layer code should never be exposed to IP addresses at all,
      just as application-layer code today is generally not exposed to details like
      MAC addresses <xref target="RFC8305"/>.</t>

      <t>The second and third steps are intentionally separate.
      In the second step, a limited amount of information (typically just the name)
      is requested about a large number of service instances.
      In the third step more detailed information
      (e.g, target host IP address, port number, etc.)
      is requested about one specific service instance.
      Requesting all the detailed information about all available
      service instances would be inefficient and wasteful on the network.
      If the information about services on the network is imagined as a table,
      then the second step is requesting just one column from that table (the name column)
      and the third step is requesting just one row from that table
      (the information pertaining to just one named service instance).</t>

      <t>To give an example, clicking the “+” button in the printer settings on macOS
      is an operation performing the second step.
      It is requesting the names of all available printers.
      Once a print queue has been configured for the chosen printer,
      subsequent printing of documents is an operation performing the third step.
      It only needs to request information about the specific printer in question.
      It is not necessary to repeatedly discover the list of every printer on the
      network if the device already knows which one it intends to use.</t>

      <t><xref target="RFC6763">DNS-Based Service Discovery</xref>
      implements these three principal service discovery operations using
      DNS records and queries, either using
      <xref target="RFC6762">Multicast DNS</xref>
      (for queries limited to the local link)
      or conventional
      unicast DNS <xref target="RFC1034"/> <xref target="RFC1035"/>
      (for queries beyond the local link).</t>

      <t>Other service discovery protocol achieve the same semantics
      using different packet formats and mechanisms.</t>

      <t>One incidental benefit of using DNS as the foundation layer
      for service discovery, in cases where that makes sense, is
      that both Multicast DNS and conventional unicast DNS are also used provide
      name resolution (mapping host names to IP addresses).
      There is some efficiency and code reuse gained by using the same
      underlying protocol for both service discovery and naming.</t>

      <t>A final requirement is that the service discovery protocol perform not only
      discovery at a single moment in time, but also ongoing change notification
      (sometimes called “Publish &amp; Subscribe”).
      Without support for ongoing change notification, clients would be
      forced to resort to polling to keep data up to date, which is
      inefficient and wasteful on the network.</t>

      <t><xref target="RFC6762">Multicast DNS</xref> implicitly includes
      change notification by virtue of announcing record changes via IP Multicast,
      which allows these changes to be seen by all peers on the same link
      (i.e., same broadcast domain).</t>

      <t>Conventional unicast DNS <xref target="RFC1034"/> <xref target="RFC1035"/>
      has historically not had broad support for change notification.
      This capability is added via the new mechanism for
      <xref target="Push">DNS Push Notifications</xref>.</t>

      <t>When using <xref target="RFC6763">DNS-Based Service Discovery</xref>
      there are two aspects to consider:
      firstly how the clients choose what DNS names to query, and what query mechanisms to use,
      and secondly how the relevant information got into the DNS namespace in
      the first place, so as to be available when clients query for it.</t>

      <t>The available namespaces are discussed below in <xref target="Namespace"/>.
      Client operation is discussed in <xref target="Client"/> and
      server operation is discussed in <xref target="Server"/>.</t>

      <t>
      </t>

<?rfc needLines="30" ?>
    </section>

    <section anchor="Namespace" title="Service Discovery Namespace">
      <t>When used with <xref target="RFC6762">Multicast DNS</xref>
      queries are automatically performed in the “.local” parent domain.</t>

      <t>When used with conventional
      unicast DNS <xref target="RFC1034"/> <xref target="RFC1035"/>
      some other domain must be used.</t>

      <t>For individuals and organizations with
      a globally-unique domain name registered to them,
      their globally-unique domain name,
      or a subdomain of it, can be used for service discovery.</t>

      <t>However, it would be convenient for capable service discovery to be
      available even to people who haven’t taken the step of registering and
      paying for a globally-unique domain name.
      For these people it would be useful if devices arrived preconfigured with
      some suitable factory-default service discovery domain, such as
      “services.home.arpa” <xref target="I-D.ietf-homenet-dot"/>.
      Services published in this factory-default service discovery domain
      would not be globally unique or globally resolvable, but they could
      have scope larger than the single link provided by Multicast DNS.</t>

      <t>
      </t>

<?rfc needLines="30" ?>
    </section>

    <section anchor="Client" title="Client Configuration and Operation">

      <t>When using <xref target="RFC6763">DNS-Based Service Discovery</xref>,
      clients have to choose what DNS names to query.</t>

      <t>When used with <xref target="RFC6762">Multicast DNS</xref>
      queries are automatically performed in the “.local” parent domain.</t>

      <t>For discovery beyond the local link, a unicast DNS domain must be used.
      This unicast DNS domain can be configured manually by the user,
      or it can be learned dynamically from the network
      (as has been done for many years at IETF meetings to facilitate discovery
      of the IETF Terminal Room printer, from outside the IETF Terminal Room).
      In the <xref target="RFC6763">DNS-SD specification</xref> section 11,
      “Discovery of Browsing and Registration Domains (Domain Enumeration)”,
      describes how a client device learns one or more recommended service
      discovery domains from the network, using the special “lb._dns-sd._udp” query.
      All of the details from that specification are not repeated here.
      </t>

      <t>Given the service type that the user or client device is seeking
      (see <xref target="Types"/>)
      and one or more service discovery domains to look in, the client then
      sends its DNS queries, and processes the responses.</t>

      <t>For some uses, one-shot conventional DNS queries and responses
      are perfectly adequate, but for service discovery,
      where a list may be displayed on a screen for a user to see,
      it is desirable to keep that list up to date without the user
      having to repeatedly tap a “refresh” button, and without the
      software repeatedly polling the network on the user’s behalf.</t>

      <t>And early solution to provide asynchronous change notifications
      for unicast DNS was the UDP-based protocol
      <xref target="DNS-LLQ">DNS Long-Lived Queries</xref>.
      This was used, among other things, by 
      Apple’s <xref target="RFC6281">Back to My Mac Service</xref>
      introduced in Mac OS X 10.5 Leopard in 2007.</t>

      <t>Recent experience has shown that an
      asynchronous change notification protocol built on TCP would be preferable,
      so the IETF is now developing
      <xref target="Push">DNS Push Notifications</xref>.</t>

      <t>Because DNS Push Notifications is built on top of a DNS TCP connection,
      DNS Push Notifications adopts the conventions specified by
      <xref target="DSO">DNS Stateful Operations</xref>
      rather than inventing its own session management mechanisms.</t>

      <t>
      </t>

<?rfc needLines="30" ?>
    </section>

    <section anchor="Server" title="Server Configuration and Operation">
      <t><xref target="Client"/> above describes how clients perform their queries.
      The related question is
      how the relevant information got into the DNS namespace in
      the first place, so as to be available when clients query for it.</t>

      <t>One way that relevant service discovery information can get into
      the DNS namespace is simply via manual configuration, creating
      the necessary PTR, SRV and TXT records <xref target="RFC6763"/>,
      and indeed this is how the IETF Terminal Room printer has been advertised
      to IETF meeting attendees for many years.
      While this is easy for the experienced network operators at the IETF, it
      can be onerous to others less familiar with how to set up DNS-SD records.</t>

      <t>Hence it would be convenient to automate this process of populating
      the DNS namespace with relevant service discovery information.
      Two efforts are underway to address this need,
      the <xref target="DisProx">Service Discovery Proxy</xref>
      (see <xref target="dp"/>)
      and
      the <xref target="RegProt">Service Registration Protocol</xref>
      (see <xref target="srp"/>).</t>

      <section anchor="dp" title="Service Discovery Proxy">

      <t>The first effort in the direction of automatically populating the DNS namespace is the
      <xref target="DisProx">Service Discovery Proxy</xref>.
      This technology is designed to work with today’s existing devices that advertise
      services using Multicast DNS only
      (such as almost all network printers sold in the last decade).
      A Service Discovery Proxy is a device colocated on the same link
      as the devices we wish to be able to discover from afar.
      A remote client sends unicast queries to the Discovery Proxy,
      which performs local Multicast DNS queries on behalf of the remote client,
      and then sends back the answers it discovers.</t>

      <t>Because the time it takes to receive Multicast DNS responses is uncertain,
      this mechanism benefits from being able to deliver asynchronous change
      notifications as new answers come in, using
      <xref target="DNS-LLQ">DNS Long-Lived Queries</xref> or the newer
      <xref target="Push">DNS Push Notifications</xref> on top of
      <xref target="DSO">DNS Stateful Operations</xref>.</t>

<?rfc needLines="30" ?>
      </section>

      <section title="Multicast DNS Discovery Relay">

      <t>As an alternative to having to be physically connected to the
      desired network link, a <xref target="DisProx">Service Discovery Proxy</xref>
      can use a <xref target="Relay">Multicast DNS Discovery Relay</xref>
      to give it a ‘virtual’ presence on a remote link.
      Indeed, when using Discovery Relays, a single Discovery Proxy
      can have a ‘virtual’ presence on hundreds of remote links.
      A single Discovery Proxy in the data center can serve the needs of an
      entire enterprise.
      This is modeled after the DHCP protocol.
      In simple residential scenarios the DHCP server resides in the
      home gateway, which is physically attached to the (single) local link.
      In complex enterprise networks, it is common to have a single centralized
      DHCP server, which resides in the data center and communicates
      with a multitude of simple lightweight BOOTP relay agents,
      implemented in the routers on each physical link.</t>

      </section>

      <section title="Service Discovery Broker">

      <t>Finally, when clients are making TCP connections to multiple
      Service Discovery Proxies at the same time, this can be burdensome for
      the clients (which may be mobile and battery powered)
      and for the the Service Discovery Proxies
      (which may have to serve hundreds of clients).
      This situation is remedied by use of a
      <xref target="Broker">Service Discovery Broker</xref>.
      A Service Discovery Broker is an intermediary between client and server.
      A client can issue a single query to the Service Discovery
      Broker and have the Service Discovery Broker do the hard work
      of issuing multiple queries on behalf of the client.
      And a Service Discovery Broker can shield a Service Discovery Proxy
      from excessive load by collapsing multiple duplicate queries from
      different client down to a single query to the Service Discovery Proxy.</t>

<?rfc needLines="40" ?>
      </section>

      <section anchor="srp" title="Service Registration Protocol">

      <t>The second effort in the direction of automatically populating the DNS namespace is the
      <xref target="RegProt">Service Registration Protocol</xref>.
      This technology is designed to enable future devices that will explicitly
      cooperate with the network infrastructure to advertise their services.</t>

      <t>The Service Registration Protocol is effectively DNS Update,
      with some minor additions.</t>

      <t>One addition is the introduction of a lifetime on DNS Updates,
      using the the
      <xref target="DNS-UL">Dynamic DNS Update Lease EDNS(0) option</xref>.
      This option has similar semantics to a DHCP address lease,
      where a device is granted an address with with a certain lease lifetime,
      and if the device fails to renew the lease before it expires then the address
      will be reclaimed and become available to be allocated to a different device.
      In cases where DHCP is being used, a device will generally request a
      DNS Update Lease with the same expiration time as its DHCP address lease.
      This way, if the device is abruptly disconnected from the network,
      around the same time as its address gets reclaimed
      its DNS records will also be garbage collected.</t>

      <t>The second addition is the introduction of information
      that tells the Service Registration server that the device
      will be going to sleep to save power, combined with
      information specifying how to wake it up again on demand,
      using the
      <xref target="Owner">EDNS(0) OWNER Option</xref>.</t>

      <t>The use of an explicit Service Registration Protocol is beneficial
      in networks where multicast is expensive, inefficient, or outright
      blocked, such as many Wi-Fi networks.
      An explicit Service Registration Protocol is also beneficial
      in networks where multicast and broadcast are supported poorly,
      if at all, such as mesh networks like those using IEEE 802.15.4.</t>

      <t>The use of power management information in the Service Registration
      messages allows devices to sleep to save power, which is especially
      beneficial for battery-powered devices in the home.</t>

<?rfc needLines="25" ?>
      </section>

    </section>

  </middle>

  <back>
    <references title="Informative References">
      <?rfc include="reference.RFC.1034" ?>
      <?rfc include="reference.RFC.1035" ?>
      <?rfc include="reference.RFC.6281" ?>
      <?rfc include="reference.RFC.6760" ?>
      <?rfc include="reference.RFC.6762" ?>
      <?rfc include="reference.RFC.6763" ?>
      <?rfc include="reference.RFC.6335" ?>
      <?rfc include="reference.RFC.8305" ?>

      <?rfc include="reference.I-D.ietf-homenet-dot" ?>

      <?rfc include="reference.I-D.ietf-dnssd-hybrid"           anchor='DisProx' ?>
      <?rfc include="reference.I-D.ietf-dnssd-push"             anchor='Push' ?>
      <?rfc include="reference.I-D.ietf-dnsop-session-signal"   anchor='DSO' ?>
      <?rfc include="reference.I-D.sekar-dns-ul"                anchor='DNS-UL' ?>
      <?rfc include="reference.I-D.sekar-dns-llq"               anchor='DNS-LLQ' ?>
      <?rfc include="reference.I-D.cheshire-edns0-owner-option" anchor='Owner' ?>
      <?rfc include="reference.I-D.sctl-service-registration"   anchor='RegProt' ?>
      <?rfc include="reference.I-D.sctl-dnssd-mdns-relay"       anchor='Relay' ?>
      <?rfc include="reference.I-D.sctl-discovery-broker"       anchor='Broker' ?>

     <reference anchor="STR"
     target="http://www.iana.org/assignments/service-names-port-numbers/">
       <front>
         <title>Service Name and Transport Protocol Port Number Registry</title>
         <author/>
         <date/>
       </front>
     </reference>

      <reference anchor="ZC">
        <front>
          <title>Zero Configuration Networking: The Definitive Guide</title>
          <author initials="S." surname="Cheshire" fullname="Stuart Cheshire"/>
          <author initials="D.H." surname="Steinberg" fullname="Daniel H. Steinberg"/>
          <date year="2005" month="December"/>
        </front>
        <seriesInfo name="O'Reilly Media, Inc." value=""/>
        <seriesInfo name="ISBN" value="0-596-10100-7"/>
      </reference>

    </references>
  </back>
</rfc>
